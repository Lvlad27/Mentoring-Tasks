4) BUILDING RESTFUL API'S USING EXPRESS
  41. INTRODUCTION
  42. RESTFUL SERVICES
  43. INTRODUCING EXPRESS
  44. BUILDING YOUR FIRST WEB SERVER
  45. NODEMON
  46. ENVIRONMENT VARIABLES
  47. ROUTE PARAMETERS
  48. HANDLING HTTP GET REQUESTS
    - res.send()
    - req.params
    - res.status
  49. HANDLING HTTP POST REQUESTS
    - read body of req => use properties to create new obj => add obj to array
    - req.body (we need to enable parsing of JSON body of request, it's not enabled by default in express)
  50. CALLING ENDPOINTS USING POSTMAN (I used insomnia)
    - sending json body with post request
  51. INPUT VALIDATION
    - always validate input from client
    - validation logic
    - RESTful convention is to return a response through the http status code 400 (bad request)
    - in real world situation use of npm package like "joi"
      - define Schema (shape of object)
      - return error in case of wrong input
  52. HANDLING HTTP PUT REQUESTS
    - Basic operations
      - Look up data => If not existing, return 404
      - Validate => If invalid, return 400
      - Update data
      - return updated data (res.send)
    - Refactor to avoid duplication
    - check request with insomnia
  53. HANDLING HTTP DELETE REQUESTS
    - Basic operations
      - Look up data => If not existing, return 404
      - Delete data
      - return same data
  54. TASK
      - create service for managing the list of genres
      - each movie has a genre, like action, horror, etc. 
      - should have an endpoint for getting the list of all genres
      - should also be able to create a new genre, as well as update,or delete an existing one.
  
  5) EXPRESS - ADVANCED TOPICS
    57. Middleware
      - is a function that takes a request object, and either returns a response to the client, or passes the control to another middleware function
        - route handler function
        - express.json method is a built in middleware function => reads request and if there is a json object in the body object of the request, it will parse the body object into a json object and then it will set request.body property.
        - this happens at runtime
        - request processing pipeline
        - request => json => route() => response
        - an express application is essentially just a bunch of middleware functions
        - The next() function is a function in the Express router which, when invoked, executes the middleware succeeding the current middleware. If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.
    58. CREATING CUSTOM MIDDLEWARE
      - can create custom middleware for different concerns, such as logging, authentication, etc.
      - // Custom middleware (applied on all routes) 
            app.use(function(req, res, next)) { 
                // … 
                next();
            } 
      - // Custom middleware (applied on routes starting with /api/admin) 
            app.use(‘/api/admin’, function(req, res, next)) { 
                // … 
                next();
            }
    59. BUILT-IN MIDDLEWARE
      - json() => to parse the body of requests with a JSON payload
      - urlencoded() => to parse the body of requests with URL-encoded payload
      - static() => to serve static files
    60. THIRD PARTY MIDDLEWARE
      - helmet()
      - morgan()
    61. ENVIRONMENTS
      - We can detect the environment in which our Node application is running (development, production, etc) using process.env.NODE_ENV and app.get(‘env’).
      - process = global object in Node that gives us access to current process
      - NODE_ENV = standard environment variable => returns the environment for this current application
        - console.log(process.env.NODE_ENV)
        - app.get('env') => this is returning 'development' by default
    62. CONFIGURATION
      - storing config settings for the application and overriding those settings in each environment (e.g. development environment uses different database for mail server)
    63. DEBUGGING
      - debug packages
      - We can use the debug package to add debugging information to an application. Prefer this approach to console.log() statements.
      - can be used for multiple namespaces
        - export DEBUG=app:startup, app:db
        - export DEBUG=app:*
        - shortcut: DEBUG=app:db nodemon index.js
    64. TEMPLATING ENGINES
      - To return HTML markup to the client, use a templating engine. There are various templating engines available out there. Pug, EJS and Mustache are the most popular ones. 
      - using Pug
    65. DATABASE INTEGRATION

  7) CRUD OPERATIONS USING MongoDB
    84. Installing MongoDb and mongosh on Windows
    85. Connect to MongoDB using Mongoose
      - Start MongoDB database:
        "C:\Program Files\MongoDB\Server\6.0\bin\mongod.exe" --dbpath="c:\data\db"
    86. Schemas
      - Schema types: String, Number, Date, Buffer, Boolean, ObjectId, Array
    87. Models
      - Schema => Model => Class => Object
    88. Saving a document
    89. Querying documents
      - .find({key: value})
      - .limit(number)
      - .sort({key: value}) => value can be 1 for ascending order and  -1 for descending order
      - .select({key: number})
    90. Comparison query operators
      - eq, ne, gt, gte, lt, lte, in, nin
      - .find({ price: 10 }) => .find( { price: { $gt: 10, $lte: 20 } })
      - .find({ price: { $in: [10, 15, 20] } })
    91. Logical query operators
      - or, and
      - .find().or([{ author: 'Mosh' }, { isPublished: true }])





----------------------------------------------------------
