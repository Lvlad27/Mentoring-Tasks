4) BUILDING RESTFUL API'S USING EXPRESS
  41. INTRODUCTION
  42. RESTFUL SERVICES
  43. INTRODUCING EXPRESS
  44. BUILDING YOUR FIRST WEB SERVER
  45. NODEMON
  46. ENVIRONMENT VARIABLES
  47. ROUTE PARAMETERS
  48. HANDLING HTTP GET REQUESTS
    - res.send()
    - req.params
    - res.status
  49. HANDLING HTTP POST REQUESTS
    - read body of req => use properties to create new obj => add obj to array
    - req.body (we need to enable parsing of JSON body of request, it's not enabled by default in express)
  50. CALLING ENDPOINTS USING POSTMAN (I used insomnia)
    - sending json body with post request
  51. INPUT VALIDATION
    - always validate input from client
    - validation logic
    - RESTful convention is to return a response through the http status code 400 (bad request)
    - in real world situation use of npm package like "joi"
      - define Schema (shape of object)
      - return error in case of wrong input
  52. HANDLING HTTP PUT REQUESTS
    - Basic operations
      - Look up data => If not existing, return 404
      - Validate => If invalid, return 400
      - Update data
      - return updated data (res.send)
    - Refactor to avoid duplication
    - check request with insomnia
  53. HANDLING HTTP DELETE REQUESTS
    - Basic operations
      - Look up data => If not existing, return 404
      - Delete data
      - return same data
  54. TASK
      - create service for managing the list of genres
      - each movie has a genre, like action, horror, etc. 
      - should have an endpoint for getting the list of all genres
      - should also be able to create a new genre, as well as update,or delete an existing one.
  
5) EXPRESS - ADVANCED TOPICS
    57. Middleware
      - is a function that takes a request object, and either returns a response to the client, or passes the control to another middleware function
        - route handler function
        - express.json method is a built in middleware function => reads request and if there is a json object in the body object of the request, it will parse the body object into a json object and then it will set request.body property.
        - this happens at runtime
        - request processing pipeline
        - request => json => route() => response
        - an express application is essentially just a bunch of middleware functions
        - The next() function is a function in the Express router which, when invoked, executes the middleware succeeding the current middleware. If the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.
    58. CREATING CUSTOM MIDDLEWARE
      - can create custom middleware for different concerns, such as logging, authentication, etc.
      - // Custom middleware (applied on all routes) 
            app.use(function(req, res, next)) { 
                // … 
                next();
            } 
      - // Custom middleware (applied on routes starting with /api/admin) 
            app.use(‘/api/admin’, function(req, res, next)) { 
                // … 
                next();
            }
    59. BUILT-IN MIDDLEWARE
      - json() => to parse the body of requests with a JSON payload
      - urlencoded() => to parse the body of requests with URL-encoded payload
      - static() => to serve static files
    60. THIRD PARTY MIDDLEWARE
      - helmet()
      - morgan()
    61. ENVIRONMENTS
      - We can detect the environment in which our Node application is running (development, production, etc) using process.env.NODE_ENV and app.get(‘env’).
      - process = global object in Node that gives us access to current process
      - NODE_ENV = standard environment variable => returns the environment for this current application
        - console.log(process.env.NODE_ENV)
        - app.get('env') => this is returning 'development' by default
    62. CONFIGURATION
      - storing config settings for the application and overriding those settings in each environment (e.g. development environment uses different database for mail server)
    63. DEBUGGING
      - debug packages
      - We can use the debug package to add debugging information to an application. Prefer this approach to console.log() statements.
      - can be used for multiple namespaces
        - export DEBUG=app:startup, app:db
        - export DEBUG=app:*
        - shortcut: DEBUG=app:db nodemon index.js
    64. TEMPLATING ENGINES
      - To return HTML markup to the client, use a templating engine. There are various templating engines available out there. Pug, EJS and Mustache are the most popular ones. 
      - using Pug
    65. DATABASE INTEGRATION

7) CRUD OPERATIONS USING MongoDB
    84. Installing MongoDb and mongosh on Windows
    85. Connect to MongoDB using Mongoose
      - Start MongoDB database:
        - run in command prompt: "C:\Program Files\MongoDB\Server\6.0\bin\mongod.exe" --dbpath="c:\data\db"
    86. Schemas
      - Schema types: String, Number, Date, Buffer, Boolean, ObjectId, Array
    87. Models
      - Schema => Model => Class => Object
    88. Saving a document
    89. Querying documents
      - .find({key: value})
      - .limit(number)
      - .sort({key: value}) => value can be 1 for ascending order and  -1 for descending order
      - .select({key: number})
    90. Comparison query operators
      - eq, ne, gt, gte, lt, lte, in, nin
      - .find({ price: 10 }) => .find( { price: { $gt: 10, $lte: 20 } })
      - .find({ price: { $in: [10, 15, 20] } })
    91. Logical query operators
      - or, and
      - .find().or([{ author: 'Mosh' }, { isPublished: true }])
    92. Regular Expressions
      - .find({ author: /^Mosh/ })
    93. Counting
      - .count() => returns the count of documents that match a given criteria
    94. Pagination
      - .skip((pageNumber - 1) * pageSize)
      - limit.(pageSize)
    95-97. Exercises
    98-99. Updating documents
      - 1st approach: Query first 
        - findById() => modify properties => save()
      - 2nd approach: update first:
        - update directly
        - optionally get updated document
      - update operators: $currentDate, $inc, $min, $max, $mul, $rename, $set, $unset, $setOnInsert\
    100. Deleting documents
      - deleteOne() => deletes first found
      - deleteMany()
      - findByIdAndRemove() => if the document doesn't exist, it will return null

8) MONGOOSE - DATA VALIDATION
  102. Validation
      - use try catch block to see error message
      - .validate() (doesn't return boolean)
      - const isValid = .validate((err) => {
        if(err) {}
      }) 
      - Why do we use two kinds of validation? (joy and mongoose validation)
        - we use Joy to make sure that the data the client is sending us is valid.
        - we use mongoose validation to make sure the data saved to the database is valid.
  103. Built-In Validators
      - validate field depending on other fields
      - we can validate with Boolean type or a function to make a type required
      - minlength, maxlength
      - enum
      - min, max
  104. Custom Validators
      - for example we need to require at least one tag and a custom message
        - tags: {
            type: Array,
            validate: {
              validator: function (v) {
                return v.length > 0;
              },
              message: 'A course should have at least one tag'
            }
          },
  105. Async validators
      -  Sometimes the validation logic may involve reading something from a database or from a remote http service. 
      - tags: {
          type: Array,
          validate: {
            isAsync: true,
            validator: function (v) {
              return new Promise((resolve, reject) => {
                setTimeout(() => {
                  const result = v && v.length > 0;
                  resolve(result);
                }, 4000);
              });
            },
            message: 'A course should have at least one tag'
          }
        },
  106. Validation errors
       - catch (ex) {
          for (field in ex.errors) {
            console.log(ex.errors[field].message);
          }
  107. SchemaType Options 
      - strings => lowercase, uppercase, trim
      - numbers => round values using getters and setters
  108. Project
     - add persistence to Genres.API
     - add customers API
     - restructuring project

9) MONGOOSE - MODELING RELATIONSHIPS BETWEEN CONNECTED DATA
  112. Modelling Relationships
    - Using references
    - using embedded documents
    To model relationships between connected data, we can either reference a document or embed it in another document. When referencing a document, there is really no relationship between these two documents. So, it is possible to reference a non-existing document.
      1) Referencing documents (normalization) is a good approach when you want to enforce data consistency. Because there will be a single instance of an object in the database. But this approach has a negative impact on the performance of your queries because in MongoDB we cannot JOIN documents as we do in relational databases. So, to get a complete representation of a document with its related documents, we need to send multiple queries to the database.

      2) Embedding documents (denormalization) solves this issue. We can read a complete representation of a document with a single query. All the necessary data is embedded in one document and its children. But this also means we’ll have multiple copies of data in different places. While storage is not an issue these days, having multiple copies means changes made to the original  document may not propagate to all copies. If the database server dies during an update, some documents will be inconsistent. For every business, for every problem, you need to ask this question: “can we tolerate data being inconsistent for a short period of time?” If not, you’ll have to use references. But again, this means that your queries will be slower.
  113. Referencing documents
    - const courseSchema = new mongoose.Schema({
        author: {
            type: mongoose.Schema.Types.ObjectId,
            ref: ‘Author’ 
        } 
      })
  114. Population
    - .populate()
  115. Embedding documents
    - Embedded documents don’t have a save method. They can only be saved in the 
context of their parent.
    - Updating an embedded document 
        const course = await Course.findById(courseId);
        course.author.name = ‘New Name’; 
        course.save();
    - Updating an embedded document 
        const course = await Course.updateOne(
          { _id: courseId }, 
          {$set: { 'author.name': 'New Name'}}
        );
    116. Using an array of sub-documents


--------------------------------------------------------------------
